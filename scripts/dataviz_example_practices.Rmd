---
title: "starting_codes"
author: "Mahmudur Rahman"
date: "03/07/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.width=8, fig.height=5)# setting the default size of the  plots within the r markdown
```
 
 Work through the code examples from the book [https://socviz.co/index.html#preface]
 
 ## Load libraries 
```{r}
my_packages <- c("tidyverse", "broom", "coefplot", "cowplot",
                 "gapminder", "GGally", "ggrepel", "ggridges", "gridExtra",
                 "here", "interplot", "margins", "maps", "mapproj",
                 "mapdata", "MASS", "quantreg", "rlang", "scales",
                 "survey", "srvyr", "viridis", "viridisLite", "devtools")

# install.packages(my_packages, repos = "http://cran.rstudio.com")
library(tidyverse)
library(ggrepel)
library(hrbrthemes)
library(ggthemes)
library(scales)
library(srvyr)
library(survey)
library(devtools)
library(socviz)
library(kableExtra)
library(here)
theme_set(theme_ipsum())

# devtools::install_github("kjhealy/socviz")
```

## Aesthetics can be mapped per geom
Below Color is mapped to continent on geom_point not on the smooth.this could be done on globally too 
```{r example}
gapminder <- gapminder::gapminder

gapminder %>% 
  ggplot(aes(gdpPercap,lifeExp))+
  geom_point(aes(color = continent))+
  geom_smooth(method = "loess")+
  scale_x_log10()


gapminder %>% 
  ggplot(aes(gdpPercap,lifeExp))+
  geom_point(aes(color = log(pop)))+
  geom_smooth(method = "loess")+
  scale_x_log10()

gapminder %>% 
  filter(continent != "Oceania",
         year >1992) %>% 
  ggplot(aes(gdpPercap,lifeExp))+
  geom_point(aes(color = factor(year)))+
  geom_smooth(method = "loess")+
  scale_x_log10()+
  facet_grid(factor(year)~ continent)+
  theme_hc()
  # theme_wsj()+
  # scale_colour_wsj("colors6")
```

# Show the right numbers 
```{r}

# faceting by continents
gapminder %>% 
  filter(continent != "Oceania") %>% 
  ggplot(aes(year, gdpPercap))+
  geom_line(aes(group = country,color = continent))+
  facet_wrap(~ continent,nrow = 1)+
  scale_y_log10(labels = dollar)+
  theme_wsj()+
  scale_color_calc()+
  labs(x = "Year",
       y = "Gdp per cappita",
       title = "Gpd per capita on four continents")

```


Plot customisation 
scale, guide  and theme function to get more ocontrol over the content and appreance of the graphs 

Approach:
We want a table of tidy data, a mapping of variables to aesthetic elements, and a particular type of graph. If you can keep sight of this, it will make it easier to confidently approach the job of getting any particular graph to look just right.
```{r}
glimpse(gss_sm) # data from socviz pkg
gss_sm 


```
Create a table from gss_sm df
```{r}
rel_by_region <- gss_sm %>% 
  group_by(bigregion,religion) %>% 
  summarise(total = n()) %>% 
  mutate(freq = total/sum(total),
         pct = round((freq*100),0))

rel_by_region %>% 
ggplot(aes(bigregion,pct,fill = religion))+
  geom_col(position = "identity") #position = "identity" means “just plot the values as given”.
  
rel_by_region %>% 
ggplot(aes(bigregion,pct,fill = religion ))+
  geom_col(position = "dodge2") + # dodge2 gets spaced bar 
  theme_ipsum()+
  labs(x = "Religion",
       y = "Percent",
       fill = "Religion")+ # Renaming legend title 
  theme(legend.position = "top",legend.title = element_text(face = "bold",size = 12))+
  theme(legend.text = element_text(face = "bold",size = 10))
  
# the plots not is not that good , two crowded, lets imporove on it .
# dodge charts can be clearly expressed as factes plots

rel_by_region %>% 
ggplot(aes(religion,pct,fill = religion ))+
  geom_col(position = "dodge2") +
  coord_flip()+
  guides(fill = F)+ # removes legend 
    facet_grid(~ bigregion)+
  labs(x = "Religion",
       y = "Percent",
       fill = "Religion")+
  theme_ipsum()
```


Continuous variables by group or category
```{r}
 # decade’s worth of information on the donation of organs for transplants in seventeen OECD countries.
# data comes from socviz library()

organdata %>% 
  select(1:5) %>% 
  sample_n(size = 10) %>% # looking at 5 columns randomly %>% 

  
organdata %>% 
    ggplot(aes(year,donors))+
    geom_line(aes(group = country))+
    facet_wrap(~ country)+
  theme_ipsum()


```

# Box plot
```{r}
#Boxplots reordered by mean donation rate.
organdata %>% 
  ggplot(aes(fct_reorder(country,donors,na.rm = TRUE),donors, fill = world))+
  geom_boxplot()+
  coord_flip()+
  theme_ipsum()+
  labs(x = NULL)+
  theme(legend.position = "top")
```

Advantage of box plot:
By default the facets are ordered alphabetically by country
Putting categorical variables on the y-axis to compare their distributions is a very useful trick. Its makes it easy to effectively present summary data on more categories. The plots can be quite compact and fit a relatively large number of cases in by row. The approach also has the advantage of putting the variable being compared onto the x-axis, which sometimes makes it easier to compare across categories.

# geom_point
```{r}
# if observation withing each category is too small, then it can be plotted with points,this time color instead of fill.default geom_point() plot shape has a color attribute, but not a fill.

organdata %>% 
  ggplot(aes(fct_reorder(country,donors,na.rm = TRUE),donors, color = world))+
  geom_point()+
  coord_flip()+
  theme_ipsum()+
  labs(x = NULL)+
  theme(legend.position = "top")


ggsave(here::here( "output", "plot_point_not_bx_plot.png"),width = 6, height = 6, dpi = 150, units = "in", device='png')

```

# geom_jitter

## geom_abline to add reference line in scatterplots

When there is over plotting of observationsin values and in order to get a better sense of how many observations there are at different values we can use geom_jitter.
geom_jitter randomly nudges observations by a small amount.

```{r}
# jitter the points/Cleveland dotplot
organdata %>% 
  ggplot(aes(fct_reorder(country,donors,na.rm = TRUE),donors, color = world))+
  geom_jitter()+
  # geom_abline(intercept = 10,size = 5,alpha = .5)+
  coord_flip()+
  theme_ipsum()+
  labs(x = NULL)+
  theme(legend.position = "top")

ggsave(here::here( "output", "geom_jitter.png"),width = 4, height = 4, dpi = 150, units = "in", device='png')
dev.off()

# dev.off() after all the plotting, to save the file and return control to the screen.
# execute this code after creating the plot to finish creating the image file

# The default amount of jitter is a little too much for our purposes. We can control it using height and width arguments to a position_jitter() function within the geom. Because we’re making a one-dimensional summary here, we just need width.
organdata %>% 
  ggplot(aes(fct_reorder(country,donors,na.rm = TRUE),donors, color = world))+
  geom_jitter(position = position_jitter(width = 0.15))+
  coord_flip()+
  # scale_color_discrete(labels = c("c","l","s","not applicable"))+#
  theme_ipsum()+
  labs(x = NULL)+
  theme(legend.position = "top")

ggsave(here::here( "output", "Cleveland dotplot.png"),width = 5, height = 5, dpi = 150, units = "in", device='png')
```

## Average donation rate
```{r}
by_country <- organdata %>% 
  group_by(consent_law,country) %>% 
  summarise(donors_mean = mean(donors, na.rm = TRUE),
            donors_sd = sd(donors, na.rm = TRUE),
              gdp_mean = mean(gdp, na.rm = TRUE),
              health_mean = mean(health, na.rm = TRUE),
              roads_mean = mean(roads, na.rm = TRUE),
              cerebvas_mean = mean(cerebvas, na.rm = TRUE))
by_country

# better approach with functional programming for above code 

# Sometimes graphing functions can get confused by grouped tibbles where we don’t explicitly use the groups in the plot.
by_country %>% 
  group_by(consent_law,country) %>% 
  summarise_if(is.numeric, funs(mean,sd), na.rm = TRUE) %>% 
  ungroup() # so that the result is a plain tibble.

```

Cleveland dotplots are generally preferred to bar or column charts.
#Figure: A Cleveland dotplot, with colored points
```{r}
p <- by_country %>% 
  ggplot(aes(donors_mean,fct_reorder(country,donors_mean),color = consent_law))

p+geom_point(size = 2)+
  labs(x= "Donor Rrocurement Rate",
       y = "",
       color = "Consent Law")+
  theme(legend.position = "top")

ggsave(here::here( "output", "donor_procurement_rate.png"),width = 6, height = 6, dpi  = 150, units = "in", device='png')
```

## Facet wrap
facet is a best way to avoid over plotting ..
where one axis is categorical, as here, we can free the categorical axis and leave the continuous one fixed. The result is that each panel shares the same x-axis, and it is easy to compare between them.
Cleveland dotplots are generally preferred to bar or column charts. When making them, put the categories on the y-axis and order them in the way that is most relevant to the numerical summary you are providing. This sort of plot is also an excellent way to summarize model results or any data with with error ranges.

facet_wrap:scales options  are:
1.scales = "free" - will have own free axis but it loose the comparibilty in data .
2.scales = "free_y"
3.scales = "free_x"


```{r}
# 
p+
 geom_point(size = 3)+
facet_wrap(~ consent_law,scales = "free_y",ncol = 1)+
    labs(x= "Donor Rrocurement Rate",
       y = "",color = "Consent Law")+
  theme(legend.position = "none")

ggsave(here::here( "output", "donor_procurement_rate_free_scaled.png"),width = 6, height = 6, dpi  = 150, units = "in", device='png')
# wihtout free_scales
p+
  geom_point(size = 3)+
facet_wrap(~ consent_law,ncol = 1)+
    labs(x= "Donor Rrocurement Rate",
       y = "",color = "Consent Law")+
  theme(legend.position = "none")
  



```

## # faced grid 
it provides a way of graphic pivoting 
```{r}
mpg %>% 
  ggplot(aes(displ,hwy))+
  geom_point()+
  facet_grid(year~ drv)


```

## Extending Cleveland-style dotplot
```{r}
by_country %>% 
  ggplot(aes(fct_reorder(country,donors_mean),donors_mean))+
  geom_pointrange(aes(ymin = donors_mean - donors_sd,
                      ymax = donors_mean + donors_sd))+
  coord_flip()+
  labs(x = "",
       y = "\nDononrs Procurement Rate",
       title = "Variance in procuremnt in each countries ")

ggsave(here::here( "output", "dot_and_whisker_plot.png"),width = 5, height = 5, dpi  = 150, units = "in", device='png')

# Figure:A dot-and-whisker plot, with the range defined by the standard deviation of the measured variable.
```

# Plot text directly
## Text labels with ggrepel
```{r}
# adding text a scatter plot

by_country %>% 
  ggplot(aes(roads_mean,donors_mean))+
  geom_point()+
  geom_text_repel(aes(label = country))

ggsave(here::here( "output", "plot_with_text.png"),width = 6, height = 6, dpi  = 150, units = "in", device='png')

```

We will use geom_text_repel() instead of geom_text(). To demonstrate some of what geom_text_repel() can do, we will switch datasets and work with some historical U.S. presidential election data provided in the socviz library.

```{r}
elections_historic %>% 
  select(2:7) %>% 
  sample_n(size= 5)

# define labels 
p_title <- "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <- "1824-2016"
p_caption <- "Data for 2016 are provisional."
x_label <- "Winner's share of Popular Vote"
y_label <- "Winner's share of Electoral College Votes"
  

# Text labels with ggrepel
elections_historic %>%
  ggplot(aes(popular_pct,ec_pct,label = winner_label))+
  geom_hline(yintercept = 0.5,size = 1.4,color = "grey")+
  geom_vline(xintercept = 0.5,size = 1.4,color = "grey")+
  geom_point()+
  geom_text_repel()+ #labels already defined globally with aes in ggplot calls
 scale_x_continuous(labels = scales::percent_format(accuracy = 2)) +
 scale_y_continuous(labels = scales::percent)+
  labs(x=x_label,
       y = y_label,
       title = p_title,
       subtitle = p_subtitle,
       caption = p_caption)


# Normally it is not a good idea to label every point on a plot in the way we do here. A better approach might be to select a few points of particular interest.

# There is also a geom_abline() geom that draws straight lines based on a supplied slope and intercept. This is useful for plotting, for example, 45 degree reference lines in scatterplots.

```

## Label outliers
##subset data with ggrepel
Sometimes we want to pick out some points of interest in the data without labeling every single item. We can still use geom_text() or geom_text_repel(). We just need to pick out the points we want to label. In the code above, we do this on the fly by telling geom_text_repel() to use a different data set from the one geom_point() is using. We do this using the subset() function.
```{r}
p <- ggplot(data = by_country,
            mapping = aes(x = gdp_mean, y = health_mean))

p + geom_point() +
    geom_text_repel(data = subset(by_country, health_mean > 3000),
                    mapping = aes(label = country))

p <- ggplot(data = by_country,
            mapping = aes(x = gdp_mean, y = health_mean))

# multiple condition applied
p + geom_point() +
  geom_text_repel(data = subset(by_country,gdp_mean >25000 | health_mean<1500 | country  %in% "Belgium"),aes(label = country))

```

Lebelling using dummy variable
```{r}
organdata$ind <- organdata$ccode %in% c("Ita", "Spa") &
                    organdata$year > 1998

p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors, color = ind))
p + geom_point() +
    geom_text_repel(data = subset(organdata, ind),
                    mapping = aes(label = ccode)) +
    guides(label = FALSE, color = FALSE)
```

# Annotation
## Write and draw in the plot area
Sometimes we want to annotate the figure directly. Maybe we need to point out something important that is not mapped to a variable.
The most obvious use-case is putting arbitrary text on the plot.
```{r}
p <- ggplot(data = organdata, mapping = aes(x = roads, y = donors))

p+
  geom_point()+
  annotate(geom = "text", x = 90, y = 30,color = "red",size = 6,
                            label = "A surprisingly high \n recovery rate.")
# annotate() with other geoms
# add rectangle to plot
# Using two different geoms with annotate().
p+
  geom_point()+
  annotate("rect", xmin = 128, xmax = 200, ymin = 25, ymax = 35,fill = "grey",
  alpha = .5)+
  annotate(geom = "text", x = 90, y = 31,color = "red",size = 5,
                            label = "A surprisingly high \n recovery rate.")

```


